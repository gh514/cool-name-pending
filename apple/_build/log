# dune exec apple
# OCAMLPARAM: unset
# Shared cache: disabled
# Shared cache location: /home/user/.cache/dune/db
# Workspace root: "/home/user/Documents/Computer Science/Part II
# Project/cool-name-pending/apple"
# Auto-detected concurrency: 6
# Dune context:
#  { name = "default"
#  ; kind = "default"
#  ; profile = Dev
#  ; merlin = true
#  ; fdo_target_exe = None
#  ; build_dir = In_build_dir "default"
#  ; instrument_with = []
#  }
$ /home/user/.opam/4.11.1/bin/ocamlc.opt -config > /tmp/dune_dbd817_output
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamldep.opt -modules -impl bin/main.ml) > _build/default/bin/.main.eobjs/dune__exe__Main.impl.d
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Ast.cmo -c -impl bin/ast.ml)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Main.cmi -c -intf bin/main.mli)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Past.cmo -c -impl bin/past.ml)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Parser.cmi -c -intf bin/parser.mli)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Ast_to_smt_lib.cmo -c -impl bin/ast_to_smt_lib.ml)
> File "bin/ast_to_smt_lib.ml", line 33, characters 4-5:
> 33 |   | _ -> ()
>          ^
> Warning 11: this match case is unused.
> File "bin/ast_to_smt_lib.ml", lines 48-52, characters 2-70:
> 48 | ..match dt with
> 49 |   | Ast.Int -> out "(declare-const"; translate_expr e; out " Int)"
> 50 |   | Ast.Bool -> out "(declare-const"; translate_expr e; out " Bool)"
> 51 |   | Ast.Cell -> raise (Err "Type Ast.Cell should not be possible")
> 52 |   | Ast.Region -> raise (Err "Type Ast.Region should not be possible")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Line
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Ast.cmx -c -impl bin/ast.ml)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Past.cmx -c -impl bin/past.ml)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Lexer.cmo -c -impl bin/lexer.ml)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Smt_lib_to_puzzle.cmo -c -impl bin/smt_lib_to_puzzle.ml)
> File "bin/smt_lib_to_puzzle.ml", line 144, characters 65-67:
> 144 |         in display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                                                        ^^
> Warning 14: illegal backslash escape in string.
> File "bin/smt_lib_to_puzzle.ml", line 148, characters 65-67:
> 148 |       else display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                                                        ^^
> Warning 14: illegal backslash escape in string.
> File "bin/smt_lib_to_puzzle.ml", lines 63-66, characters 21-18:
> 63 | .....................function
> 64 |         | (var, BoolVar(b))::ls -> if Str.string_match (Str.regexp v) var 0 && b then 
> 65 |           get_end var::loop ls else loop ls
> 66 |         | [] -> []
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, IntVar _)::_
> File "bin/smt_lib_to_puzzle.ml", line 86, characters 10-15:
> 86 |   let rec store (v, x) vs =
>                ^^^^^
> Warning 39: unused rec flag.
> File "bin/smt_lib_to_puzzle.ml", line 112, characters 42-116:
> 112 |         in let to_cells = List.filter_map (fun (v, BoolVar(b)) -> if b then Some (extract_rc (get_end v)) else None) line_segments
>                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, IntVar _)
> File "bin/smt_lib_to_puzzle.ml", line 144, characters 102-103:
> 144 |         in display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                                                                                             ^
> Warning 28: wildcard pattern given as argument to a constant constructor
> File "bin/smt_lib_to_puzzle.ml", line 148, characters 102-103:
> 148 |       else display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                                                                                             ^
> Warning 28: wildcard pattern given as argument to a constant constructor
> File "bin/smt_lib_to_puzzle.ml", lines 154-161, characters 54-55:
> 154 | ......................................................function
> 155 |     | (Past.Int, Past.Var(_, v), _)::ls -> sort (v::ints) bools cells regions lines boxes ls
> 156 |     | (Past.Bool, Past.Var(_, v), _)::ls -> sort ints (v::bools) cells regions lines boxes ls
> 157 |     | (Past.Cell, Past.Var(_, v), _)::ls -> sort ints bools (v::cells) regions lines boxes ls
> 158 |     | (Past.Region, Past.Var(_, v), _)::ls -> sort ints bools cells (v::regions) lines boxes ls
> 159 |     | (Past.Box, Past.Var(_, v), _)::ls -> sort ints bools cells regions lines (v::boxes) ls
> 160 |     | (_, Past.Var(_, v), _)::ls -> sort ints bools cells regions (v::lines) boxes ls
> 161 |     | [] -> (ints, bools, cells, regions, lines, boxes)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_,
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)), _)::_
> File "bin/smt_lib_to_puzzle.ml", line 171, characters 22-75:
> 171 |   in let _ = List.map (fun (v, IntVar(x)) -> Printf.printf "%s = %i\n" v x) (reorder dims cells)
>                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, BoolVar _)
> File "bin/smt_lib_to_puzzle.ml", line 174, characters 60-104:
> 174 |   in let _ = List.map (fun v -> Printf.printf "%s = %i\n" v (let IntVar(i) = List.assoc v all_vars in i)) ints
>                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> BoolVar _
> File "bin/smt_lib_to_puzzle.ml", line 175, characters 52-97:
> 175 |   in List.map (fun v -> Printf.printf "%s = %b\n" v (let BoolVar(b) = List.assoc v all_vars in b)) bools
>                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> IntVar _
> File "bin/smt_lib_to_puzzle.ml", line 46, characters 13-16:
> 46 | let reorder (row, col) vars = 
>                   ^^^
> Warning 27: unused variable row.
> File "bin/smt_lib_to_puzzle.ml", line 83, characters 40-41:
> 83 |     then out "Regions:"; List.map (fun (v, ls) -> out "\n"; display ls) (group [] (List.map (fun (v, x) -> (get_start v, x)) (reorder (r, c) model_regions)))
>                                              ^
> Warning 27: unused variable v.
> File "bin/smt_lib_to_puzzle.ml", line 85, characters 15-16:
> 85 | let get_lines (r, c) vars lines = 
>                     ^
> Warning 27: unused variable r.
> File "bin/smt_lib_to_puzzle.ml", line 85, characters 18-19:
> 85 | let get_lines (r, c) vars lines = 
>                        ^
> Warning 27: unused variable c.
> File "bin/smt_lib_to_puzzle.ml", line 126, characters 92-94:
> 126 |             | (p, c)::ls -> if p = List.hd line then order (c::line) (List.filter (fun (sp, sc) -> sp != List.hd line) segments)
>                                                                                                   ^^
> Warning 27: unused variable sc.
> File "bin/smt_lib_to_puzzle.ml", line 144, characters 28-29:
> 144 |         in display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                   ^
> Warning 26: unused variable t.
> File "bin/smt_lib_to_puzzle.ml", line 148, characters 28-29:
> 148 |       else display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                   ^
> Warning 26: unused variable t.
> File "bin/smt_lib_to_puzzle.ml", line 162, characters 23-28:
> 162 |   in let (ints, bools, cells, regions, lines, boxes) = sort [] [] [] [] [] [] named_vars
>                              ^^^^^
> Warning 27: unused variable cells.
> File "bin/smt_lib_to_puzzle.ml", line 162, characters 46-51:
> 162 |   in let (ints, bools, cells, regions, lines, boxes) = sort [] [] [] [] [] [] named_vars
>                                                     ^^^^^
> Warning 27: unused variable boxes.
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Lexer.cmx -c -impl bin/lexer.ml)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Parser.cmx -c -impl bin/parser.ml)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Ast_to_smt_lib.cmx -c -impl bin/ast_to_smt_lib.ml)
> File "bin/ast_to_smt_lib.ml", line 33, characters 4-5:
> 33 |   | _ -> ()
>          ^
> Warning 11: this match case is unused.
> File "bin/ast_to_smt_lib.ml", lines 48-52, characters 2-70:
> 48 | ..match dt with
> 49 |   | Ast.Int -> out "(declare-const"; translate_expr e; out " Int)"
> 50 |   | Ast.Bool -> out "(declare-const"; translate_expr e; out " Bool)"
> 51 |   | Ast.Cell -> raise (Err "Type Ast.Cell should not be possible")
> 52 |   | Ast.Region -> raise (Err "Type Ast.Region should not be possible")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Line
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Smt_lib_to_puzzle.cmx -c -impl bin/smt_lib_to_puzzle.ml)
> File "bin/smt_lib_to_puzzle.ml", line 144, characters 65-67:
> 144 |         in display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                                                        ^^
> Warning 14: illegal backslash escape in string.
> File "bin/smt_lib_to_puzzle.ml", line 148, characters 65-67:
> 148 |       else display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                                                        ^^
> Warning 14: illegal backslash escape in string.
> File "bin/smt_lib_to_puzzle.ml", lines 63-66, characters 21-18:
> 63 | .....................function
> 64 |         | (var, BoolVar(b))::ls -> if Str.string_match (Str.regexp v) var 0 && b then 
> 65 |           get_end var::loop ls else loop ls
> 66 |         | [] -> []
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, IntVar _)::_
> File "bin/smt_lib_to_puzzle.ml", line 86, characters 10-15:
> 86 |   let rec store (v, x) vs =
>                ^^^^^
> Warning 39: unused rec flag.
> File "bin/smt_lib_to_puzzle.ml", line 112, characters 42-116:
> 112 |         in let to_cells = List.filter_map (fun (v, BoolVar(b)) -> if b then Some (extract_rc (get_end v)) else None) line_segments
>                                                 ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, IntVar _)
> File "bin/smt_lib_to_puzzle.ml", line 144, characters 102-103:
> 144 |         in display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                                                                                             ^
> Warning 28: wildcard pattern given as argument to a constant constructor
> File "bin/smt_lib_to_puzzle.ml", line 148, characters 102-103:
> 148 |       else display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                                                                                             ^
> Warning 28: wildcard pattern given as argument to a constant constructor
> File "bin/smt_lib_to_puzzle.ml", lines 154-161, characters 54-55:
> 154 | ......................................................function
> 155 |     | (Past.Int, Past.Var(_, v), _)::ls -> sort (v::ints) bools cells regions lines boxes ls
> 156 |     | (Past.Bool, Past.Var(_, v), _)::ls -> sort ints (v::bools) cells regions lines boxes ls
> 157 |     | (Past.Cell, Past.Var(_, v), _)::ls -> sort ints bools (v::cells) regions lines boxes ls
> 158 |     | (Past.Region, Past.Var(_, v), _)::ls -> sort ints bools cells (v::regions) lines boxes ls
> 159 |     | (Past.Box, Past.Var(_, v), _)::ls -> sort ints bools cells regions lines (v::boxes) ls
> 160 |     | (_, Past.Var(_, v), _)::ls -> sort ints bools cells regions (v::lines) boxes ls
> 161 |     | [] -> (ints, bools, cells, regions, lines, boxes)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_,
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)), _)::_
> File "bin/smt_lib_to_puzzle.ml", line 171, characters 22-75:
> 171 |   in let _ = List.map (fun (v, IntVar(x)) -> Printf.printf "%s = %i\n" v x) (reorder dims cells)
>                             ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, BoolVar _)
> File "bin/smt_lib_to_puzzle.ml", line 174, characters 60-104:
> 174 |   in let _ = List.map (fun v -> Printf.printf "%s = %i\n" v (let IntVar(i) = List.assoc v all_vars in i)) ints
>                                                                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> BoolVar _
> File "bin/smt_lib_to_puzzle.ml", line 175, characters 52-97:
> 175 |   in List.map (fun v -> Printf.printf "%s = %b\n" v (let BoolVar(b) = List.assoc v all_vars in b)) bools
>                                                           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> IntVar _
> File "bin/smt_lib_to_puzzle.ml", line 46, characters 13-16:
> 46 | let reorder (row, col) vars = 
>                   ^^^
> Warning 27: unused variable row.
> File "bin/smt_lib_to_puzzle.ml", line 83, characters 40-41:
> 83 |     then out "Regions:"; List.map (fun (v, ls) -> out "\n"; display ls) (group [] (List.map (fun (v, x) -> (get_start v, x)) (reorder (r, c) model_regions)))
>                                              ^
> Warning 27: unused variable v.
> File "bin/smt_lib_to_puzzle.ml", line 85, characters 15-16:
> 85 | let get_lines (r, c) vars lines = 
>                     ^
> Warning 27: unused variable r.
> File "bin/smt_lib_to_puzzle.ml", line 85, characters 18-19:
> 85 | let get_lines (r, c) vars lines = 
>                        ^
> Warning 27: unused variable c.
> File "bin/smt_lib_to_puzzle.ml", line 126, characters 92-94:
> 126 |             | (p, c)::ls -> if p = List.hd line then order (c::line) (List.filter (fun (sp, sc) -> sp != List.hd line) segments)
>                                                                                                   ^^
> Warning 27: unused variable sc.
> File "bin/smt_lib_to_puzzle.ml", line 144, characters 28-29:
> 144 |         in display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                   ^
> Warning 26: unused variable t.
> File "bin/smt_lib_to_puzzle.ml", line 148, characters 28-29:
> 148 |       else display (try let t  = Str.search_forward (Str.regexp "\.") source 0 in ".5" with Not_found _ -> "")
>                                   ^
> Warning 26: unused variable t.
> File "bin/smt_lib_to_puzzle.ml", line 162, characters 23-28:
> 162 |   in let (ints, bools, cells, regions, lines, boxes) = sort [] [] [] [] [] [] named_vars
>                              ^^^^^
> Warning 27: unused variable cells.
> File "bin/smt_lib_to_puzzle.ml", line 162, characters 46-51:
> 162 |   in let (ints, bools, cells, regions, lines, boxes) = sort [] [] [] [] [] [] named_vars
>                                                     ^^^^^
> Warning 27: unused variable boxes.
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlc.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -bin-annot -I bin/.main.eobjs/byte -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/byte/dune__exe__Past_to_ast.cmo -c -impl bin/past_to_ast.ml)
> File "bin/past_to_ast.ml", lines 15-33, characters 21-45:
> 15 | .....................function
> 16 |   | Past.Integer(l, _) -> raise (Err "int")
> 17 |   | Past.Boolean(l, _) -> raise (Err "bool")
> 18 |   | Past.RC(l, _, _) -> raise (Err "rc")
> 19 |   | Past.Var(l, _) -> raise (Err "var")
> ...
> 30 |   | Past.Member(l, _, _) -> raise (Err "member")
> 31 |   | Past.Sugar(l, _, _, _) -> raise (Err "sugar")
> 32 |   | Past.CellDec(l, _) -> raise (Err "celldec")
> 33 |   | Past.ITE(l, _, _, _) -> raise (Err "ite")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Corner (_, _)
> File "bin/past_to_ast.ml", lines 57-75, characters 14-29:
> 57 | ..............function
> 58 |   | Past.Integer(l, _) -> l
> 59 |   | Past.Boolean(l, _) -> l
> 60 |   | Past.RC(l, _, _) -> l
> 61 |   | Past.Var(l, _) -> l
> ...
> 72 |   | Past.Member(l, _, _) -> l
> 73 |   | Past.Sugar(l, _, _, _) -> l
> 74 |   | Past.CellDec(l, _) -> l
> 75 |   | Past.ITE(l, _, _, _) -> l
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Corner (_, _)
> File "bin/past_to_ast.ml", line 104, characters 19-74:
> 104 |   | Past.Var(_) -> let (_, Some e2) = safe_find e vars in eval_num e2 vars 
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, None)
> File "bin/past_to_ast.ml", lines 111-113, characters 32-41:
> 111 | ................................(match uop with
> 112 |     | Past.Neg -> - eval_num e1 vars
> 113 |     | Past.Abs -> abs (eval_num e1 vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Not
> File "bin/past_to_ast.ml", lines 118-131, characters 20-31:
> 118 | ....................match e with
> 119 |   | Past.RC(_, r, c) -> 
> 120 |     let check_rc x limit = if 1 <= x && x <= limit then x else raise (Err "Invalid index")
> 121 |     in let f e2 limit =
> 122 |      match e2 with
> ...
> 128 |           | None -> raise (RegVar e2))
> 129 |       | Past.Corner(_, Past.Integer(_, i)) -> i
> 130 |       | _ -> eval_num e2 vars
> 131 |     in (f r !gridr, f c !gridc)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", line 133, characters 8-18:
> 133 | let rec substitute var_new var_old expr =
>               ^^^^^^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", lines 257-294, characters 2-167:
> 257 | ..let Ast.Var(nl) = l
> 258 |   in let (adj_lines, linevars) = create_linevars (x-1)
> 259 |   in let line_segments = List.concat_map (fun (rc1, rc2) -> [(rc1, rc2); (rc2, rc1)]) adj_lines
> 260 |   in let to_var (r1, c1) (r2, c2) = Ast.Var(sprintf "%s_r%i%sc%i%stor%i%sc%i%s" nl r1 s c1 s r2 s c2 s )
> 261 |   in let to_cell (r, c) ss = Ast.Var(sprintf "%s_r%i%sc%i%s%s" nl r s c s ss)
> ...
> 291 |     @ (if line then [] else List.map (fun rc1 -> Ast.Op(to_cell rc1 "_sink", Ast.LeftImp, Ast.UnaryOp(Ast.Not, Ast.MultiOp(Ast.Or, 
> 292 |       List.map (fun rc2 -> to_var rc1 rc2) (surrounding x rc1))))) cells)
> 293 |     @ (if line then [] else List.map (fun rc1 -> Ast.Op(Ast.Op(Ast.UnaryOp(Ast.Not, to_cell rc1 "_source"), Ast.And, to_cell rc1 ""), Ast.LeftImp, 
> 294 |       Ast.Op(Ast.MultiOp(Ast.Add, List.map (fun rc2 -> Ast.ITE(to_var rc2 rc1, Ast.Integer(1), Ast.Integer(0))) (surrounding x rc1)), Ast.GTE, Ast.Integer(1)))) cells)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
> Dec (_, _)|Bundle _|ITE (_, _, _))
> File "bin/past_to_ast.ml", line 317, characters 10-28:
> 317 |   let rec parent_constraints r c =
>                 ^^^^^^^^^^^^^^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", lines 464-466, characters 2-70:
> 464 | ..let Past.Var(_, v1) = nv in
> 465 |   let (lines, nvars) = translate_centreline l v1 vars
> 466 |   in (Ast.Bundle(init@lines), (Past.CentreLine, nv, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 469-471, characters 2-68:
> 469 | ..let Past.Var(_, v1) = nv in
> 470 |   let (lines, nvars) = translate_edgeline l v1 vars
> 471 |   in (Ast.Bundle(init@lines), (Past.EdgeLine, nv, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 474-476, characters 2-70:
> 474 | ..let Past.Var(_, v1) = nv in
> 475 |   let (lines, nvars) = translate_centreline l v1 vars
> 476 |   in (Ast.Bundle(init@lines), (Past.CentreLoop, nv, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 479-481, characters 2-68:
> 479 | ..let Past.Var(_, v1) = nv in
> 480 |   let (lines, nvars) = translate_edgeline l v1 vars
> 481 |   in (Ast.Bundle(init@lines), (Past.EdgeLoop, nv, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 486-489, characters 17-14:
> 486 | .................function
> 487 |     | Past.Range(_, Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)), Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)))::cs -> 
> 488 |       [(r1, c1); (r2, c2)]@(loop cs)
> 489 |     | [] -> []
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Range
>    (_, RC (_, Integer (_, _), Integer (_, _)),
>    RC
>      (_, Integer (_, _),
>      (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>      UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>      Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>      Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>      ITE (_, _, _, _))))::
>  _|
> Range
>   (_, RC (_, Integer (_, _), Integer (_, _)),
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _))::
> _|
> Range
>   (_, RC (_, Integer (_, _), Integer (_, _)),
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))::
> _|
> Range
>   (_,
>   RC
>     (_, Integer (_, _),
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _))),
>   _)::
> _|
> Range
>   (_,
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _),
>   _)::
> _|
> Range
>   (_,
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)::
> _|
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Group (_, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))::_)
> File "bin/past_to_ast.ml", line 581, characters 46-140:
> 581 |         | Past.Quantifier(l, q, e1, g, e2) -> let Past.Group(_, ng) = loop (Past.Group(l, g)) in Past.Quantifier(l, q, loop e1, ng, loop e2)
>                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", line 632, characters 13-18:
> 632 |   in let rec loop2 ls = function
>                    ^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", line 629, characters 8-21:
> 629 | let rec replace_utils expr vs = 
>               ^^^^^^^^^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", line 674, characters 27-118:
> 674 |     | Past.Var(_, _), _ -> let Past.SpecOp(_, _, nsop, _) = replace_spec_op (Past.SpecOp(l, e1, sop, e2)) vars in nsop
>                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", line 675, characters 27-118:
> 675 |     | _, Past.Var(_, _) -> let Past.SpecOp(_, _, nsop, _) = replace_spec_op (Past.SpecOp(l, e1, sop, e2)) vars in nsop
>                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 681-683, characters 6-110:
> 681 | ......let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 682 |       ((if (abs (r1-r2) + abs (c1-c2)) = 1 then 
> 683 |       Ast.Op(Ast.Var(sprintf "%s_root" v1), Ast.Unequal, Ast.Var(sprintf "%s_root" v2)) else Ast.Dead), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 680-683, characters 29-110:
> 680 | .............................let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 681 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 682 |       ((if (abs (r1-r2) + abs (c1-c2)) = 1 then 
> 683 |       Ast.Op(Ast.Var(sprintf "%s_root" v1), Ast.Unequal, Ast.Var(sprintf "%s_root" v2)) else Ast.Dead), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 685-686, characters 6-128:
> 685 | ......let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 686 |       ((if (abs (r1-r2) <= 1 && abs(c1-c2) <= 1 && (r1, c1) <> (r2, c2)) then Ast.Boolean(true) else Ast.Boolean(false)), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 684-686, characters 27-128:
> 684 | ...........................let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 685 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 686 |       ((if (abs (r1-r2) <= 1 && abs(c1-c2) <= 1 && (r1, c1) <> (r2, c2)) then Ast.Boolean(true) else Ast.Boolean(false)), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 688-689, characters 6-97:
> 688 | ......let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 689 |       ((if (abs (r1-r2) + abs(c1-c2)) = 1 then Ast.Boolean(true) else Ast.Boolean(false)), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 687-689, characters 27-97:
> 687 | ...........................let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 688 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 689 |       ((if (abs (r1-r2) + abs(c1-c2)) = 1 then Ast.Boolean(true) else Ast.Boolean(false)), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 695-700, characters 24-34:
> 695 | ........................function
> 696 |         | Past.Range(_, Past.RC(_, Past.Integer(_, ra1), Past.Integer(_, ca1)), 
> 697 |           Past.RC(_, Past.Integer(_, ra2), Past.Integer(_, ca2)))::es -> 
> 698 |           if (r1, c1, r2, c2) = (ra1, ca1, ra2, ca2) || (r1, c1, r2, c2) = (ra2, ca2, ra1, ca1)
> 699 |           then Ast.Boolean(true) else loop es
> 700 |         | [] -> Ast.Boolean(false)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Range
>    (_, RC (_, Integer (_, _), Integer (_, _)),
>    RC
>      (_, Integer (_, _),
>      (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>      UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>      Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>      Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>      ITE (_, _, _, _))))::
>  _|
> Range
>   (_, RC (_, Integer (_, _), Integer (_, _)),
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _))::
> _|
> Range
>   (_, RC (_, Integer (_, _), Integer (_, _)),
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))::
> _|
> Range
>   (_,
>   RC
>     (_, Integer (_, _),
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _))),
>   _)::
> _|
> Range
>   (_,
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _),
>   _)::
> _|
> Range
>   (_,
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)::
> _|
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Group (_, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))::_)
> File "bin/past_to_ast.ml", lines 694-701, characters 6-16:
> 694 | ......let (_, Some (Past.List(_, ls))) = safe_find v vars 
> 695 |       in let rec loop = function
> 696 |         | Past.Range(_, Past.RC(_, Past.Integer(_, ra1), Past.Integer(_, ca1)), 
> 697 |           Past.RC(_, Past.Integer(_, ra2), Past.Integer(_, ca2)))::es -> 
> 698 |           if (r1, c1, r2, c2) = (ra1, ca1, ra2, ca2) || (r1, c1, r2, c2) = (ra2, ca2, ra1, ca1)
> 699 |           then Ast.Boolean(true) else loop es
> 700 |         | [] -> Ast.Boolean(false)
> 701 |       in loop ls.......................
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((_,
>  Some
>    (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>    Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>    Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> (_, None))
> File "bin/past_to_ast.ml", lines 692-701, characters 6-39:
> 692 | ......let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 693 |       ((if abs (r1-r2) <= 1 && abs (c1-c2) <= 1 then
> 694 |       let (_, Some (Past.List(_, ls))) = safe_find v vars 
> 695 |       in let rec loop = function
> 696 |         | Past.Range(_, Past.RC(_, Past.Integer(_, ra1), Past.Integer(_, ca1)), 
> 697 |           Past.RC(_, Past.Integer(_, ra2), Past.Integer(_, ca2)))::es -> 
> 698 |           if (r1, c1, r2, c2) = (ra1, ca1, ra2, ca2) || (r1, c1, r2, c2) = (ra2, ca2, ra1, ca1)
> 699 |           then Ast.Boolean(true) else loop es
> 700 |         | [] -> Ast.Boolean(false)
> 701 |       in loop ls else Ast.Dead), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 691-701, characters 6-39:
> 691 | ......let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 692 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 693 |       ((if abs (r1-r2) <= 1 && abs (c1-c2) <= 1 then
> 694 |       let (_, Some (Past.List(_, ls))) = safe_find v vars 
> 695 |       in let rec loop = function
> ...
> 698 |           if (r1, c1, r2, c2) = (ra1, ca1, ra2, ca2) || (r1, c1, r2, c2) = (ra2, ca2, ra1, ca1)
> 699 |           then Ast.Boolean(true) else loop es
> 700 |         | [] -> Ast.Boolean(false)
> 701 |       in loop ls else Ast.Dead), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 713-715, characters 10-99:
> 713 | ..........(match e1, e2 with
> 714 |         | Past.Var(_, v), Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)) -> num_constr r c v n
> 715 |         | Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)), Past.Var(_, v) -> num_constr r c v n)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((RC (_, Integer (_, _), Integer (_, _)),
>  (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
>  UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>  Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>  Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>  ITE (_, _, _, _)))|
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _))),
> _)|
> (RC
>    (_,
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)), _),
> _)|
> (Var (_, _),
> RC
>   (_, Integer (_, _),
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _))))|
> (Var (_, _),
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _))|
> (Var (_, _),
> (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)))|
> ((Integer (_, _)|Boolean (_, _)|Corner (_, _)|Op (_, _, _, _)|
>  UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>  Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>  Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>  ITE (_, _, _, _)),
> _))
> File "bin/past_to_ast.ml", lines 678-717, characters 2-69:
> 678 | ..let (Ast.Var(v2), vars2) = translate_expr e2 vars1 in
> 679 |   match sop1 with
> 680 |     | Past.RegionAdjacent -> let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 681 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 682 |       ((if (abs (r1-r2) + abs (c1-c2)) = 1 then 
> ...
> 714 |         | Past.Var(_, v), Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)) -> num_constr r c v n
> 715 |         | Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)), Past.Var(_, v) -> num_constr r c v n)
> 716 |         , vars2)
> 717 |     | Past.Adjacent(_) -> raise (Err "Adj operation not substituted")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", lines 677-717, characters 5-69:
> 677 | .....let (Ast.Var(v1), vars1) = translate_expr e1 vars in
> 678 |   let (Ast.Var(v2), vars2) = translate_expr e2 vars1 in
> 679 |   match sop1 with
> 680 |     | Past.RegionAdjacent -> let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 681 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> ...
> 714 |         | Past.Var(_, v), Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)) -> num_constr r c v n
> 715 |         | Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)), Past.Var(_, v) -> num_constr r c v n)
> 716 |         , vars2)
> 717 |     | Past.Adjacent(_) -> raise (Err "Adj operation not substituted")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", lines 723-725, characters 18-67:
> 723 | ..................(match e with
> 724 |       | Some Past.Integer(_, i) -> (Ast.Bundle([Ast.Dec(Ast.Int, nv); Ast.Op(nv, Ast.Equal, Ast.Integer(i))]), (Past.Int, v1, e)::vars)
> 725 |       | None -> (Ast.Dec(Ast.Int, nv), (Past.Int, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Some
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 726-728, characters 19-69:
> 726 | ...................(match e with
> 727 |       | Some Past.Boolean(_, b) -> (Ast.Bundle([Ast.Dec(Ast.Bool, nv); nv]), (Past.Bool, v1, e)::vars)
> 728 |       | None -> (Ast.Dec(Ast.Bool, nv), (Past.Bool, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Some
>   (Integer (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 729-730, characters 19-56:
> 729 | ...................(match e with 
> 730 |       | None -> (Ast.Dead, (Past.Cell, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Some _
> File "bin/past_to_ast.ml", lines 732-736, characters 6-66:
> 732 | ......(match e with
> 733 |       | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_region l init v1 vars
> 734 |       | Some Past.Var(l, v2) -> let (dt, expr) = safe_find (Past.Var(l, v2)) vars 
> 735 |         in (Ast.Dead, (dt, (Past.Var(l, v2)), expr)::vars)
> 736 |       | None -> (Ast.Bundle(init), (Past.Region, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Range (_, _, _)|
>   Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 738-740, characters 6-70:
> 738 | ......(match e with
> 739 |       | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_centreline l init v1 vars
> 740 |       | None -> (Ast.Bundle(init), (Past.CentreLine, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 742-744, characters 6-70:
> 742 | ......(match e with
> 743 |         | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_edgeline l init v1 vars
> 744 |         | None -> (Ast.Bundle(init), (Past.EdgeLine, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 746-748, characters 6-70:
> 746 | ......(match e with
> 747 |       | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_centreloop l init v1 vars(*fix*)
> 748 |       | None -> (Ast.Bundle(init), (Past.CentreLine, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 750-752, characters 6-70:
> 750 | ......(match e with
> 751 |       | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_edgeloop l init v1 vars(*fix*)
> 752 |       | None -> (Ast.Bundle(init), (Past.CentreLine, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", line 756, characters 6-7:
> 756 |     | _ -> raise (Err "Unimplemented datatype")
>             ^
> Warning 11: this match case is unused.
> File "bin/past_to_ast.ml", line 760, characters 6-9:
> 760 |     | [v] -> [helper v vars]
>             ^^^
> Warning 11: this match case is unused.
> File "bin/past_to_ast.ml", lines 762-764, characters 5-88:
> 762 | .....match v with 
> 763 |     | Past.List(_, l) -> let nl = loop vars l in
> 764 |       let (es, vs) = List.split nl in (Ast.Bundle(es), List.nth vs ((List.length vs)-1))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", line 769, characters 21-73:
> 769 |     | Past.Region -> let Past.List(_, l) = e in define_region l [] v vars
>                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 770-772, characters 25-67:
> 770 | .........................let Past.List(_, l) = e in 
> 771 |       let (line, nvars) = translate_centreline l (get_var v) vars
> 772 |       in (Ast.Bundle(line), (Past.CentreLine, v, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 768-772, characters 5-67:
> 768 | .....match dt with
> 769 |     | Past.Region -> let Past.List(_, l) = e in define_region l [] v vars
> 770 |     | Past.CentreLine -> let Past.List(_, l) = e in 
> 771 |       let (line, nvars) = translate_centreline l (get_var v) vars
> 772 |       in (Ast.Bundle(line), (Past.CentreLine, v, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Int|Bool|Cell|EdgeLine|CentreLoop|EdgeLoop|Box)
> File "bin/past_to_ast.ml", lines 775-780, characters 2-63:
> 775 | ..match u with
> 776 |     | Past.Size -> (match e with
> 777 |       | Past.Utils(_, e1, Past.Reg) -> translate_utils e1 u vars
> 778 |       | _ -> (Ast.Var(sprintf "%s_size" (get_var e)), vars))
> 779 |     | Past.Reg -> (Ast.Var(sprintf "%s_root" (get_var e)), vars)
> 780 |     | Past.Sum -> (Ast.Var(sprintf "%s_sum" (get_var e)), vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Cells|Value|Length)
> File "bin/past_to_ast.ml", lines 786-788, characters 20-31:
> 786 | ....................match q with
> 787 |         | Past.ForAll -> Ast.And
> 788 |         | Past.Exists -> Ast.Or
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (NForAll|NExists)
> File "bin/past_to_ast.ml", lines 793-797, characters 10-15:
> 793 | ..........let Past.Dec(_, dt, _, _) = d in
> 794 |           let (nv, _) = translate_quantifier l q (Past.Dec(l, Past.Cell, Past.List(l, vs), None)) ng
> 795 |             (Past.Quantifier(l, q, (Past.Dec(l, Past.Cell, Past.List(l, [vx]), None)), ng,
> 796 |             replace_spec_op c (store_vars dt vars ls))) vars
> 797 |           in nv
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 789-797, characters 33-15:
> 789 | .................................match ls with
> 790 |         | [vx] -> Ast.MultiOp(op, List.map (fun rc -> let (expr, _) = 
> 791 |           translate_expr (substitute rc (get_var vx) c) vars in expr) group)
> 792 |         | vx::vs ->
> 793 |           let Past.Dec(_, dt, _, _) = d in
> 794 |           let (nv, _) = translate_quantifier l q (Past.Dec(l, Past.Cell, Past.List(l, vs), None)) ng
> 795 |             (Past.Quantifier(l, q, (Past.Dec(l, Past.Cell, Past.List(l, [vx]), None)), ng,
> 796 |             replace_spec_op c (store_vars dt vars ls))) vars
> 797 |           in nv
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> []
> File "bin/past_to_ast.ml", lines 798-807, characters 9-64:
> 798 | .........match d with
> 799 |         | Past.Dec(_, Past.Cell, Past.List(_, ls), _) -> 
> 800 |           (match g with
> 801 |             | Past.Row(Some (Past.Var(_, v))) -> (Ast.MultiOp(Or, (List.mapi (fun i -> fun group -> 
> 802 |                 Ast.Op(Ast.Op(Ast.Var(v), Ast.Equal, Ast.Integer(!gridr-i)), Ast.And, split group (Past.Row(Some (Past.Integer(l, !gridr-i)))) ls)) 
> 803 |                 (List.map (fun lss -> List.map (fun (r, c) -> Past.RC(l, Past.Integer(l, r), Past.Integer(l, c))) lss) (rows ())))), vars)
> 804 |             | _ -> (split (translate_group l g vars) g ls, vars))
> 805 |         | Past.Dec(_, Past.Region, Past.List(_, ls), _) ->
> 806 |           let (reg, _) = translate_expr d vars 
> 807 |           in (Ast.Bundle(reg::[split (cell_grid l) g ls]), vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Dec
>    (_, Cell,
>    (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>    Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>    Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)), _)|
> Dec
>   (_, Region,
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Dec (_, (Int|Bool|CentreLine|EdgeLine|CentreLoop|EdgeLoop|Box), _, _)|
> Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 816-817, characters 11-61:
> 816 | ...........match e1 with
> 817 |         | Some (Past.Integer(_, i)) -> List.map to_rc (row i).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _))|
> None)
> File "bin/past_to_ast.ml", lines 813-817, characters 26-62:
> 813 | ..........................(match e with
> 814 |       | Past.Integer(_, i) -> List.map to_rc (row i)
> 815 |       | Past.Var(_) -> let (_, e1) = safe_find e vars 
> 816 |         in match e1 with
> 817 |         | Some (Past.Integer(_, i)) -> List.map to_rc (row i))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|UnaryOp (_, _, _)|
> SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
> Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|Range (_, _, _)|
> Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 821-824, characters 11-93:
> 821 | ...........match dt, ls with
> 822 |           | Past.Box, Past.List(_, list) -> list
> 823 |           | Past.Region, Past.List(_, list) -> list
> 824 |           | Past.CentreLine, Past.List(_, list) -> List.map to_rc (get_centreline_cells list).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((CentreLine,
>  (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>  Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>  Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>  Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>  ITE (_, _, _, _)))|
> (Region,
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)))|
> (Box,
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)))|((Int|Bool|Cell|EdgeLine|CentreLoop|EdgeLoop), _))
> File "bin/past_to_ast.ml", lines 820-824, characters 23-93:
> 820 | .......................let (dt, Some ls) = safe_find e vars 
> 821 |         in match dt, ls with
> 822 |           | Past.Box, Past.List(_, list) -> list
> 823 |           | Past.Region, Past.List(_, list) -> list
> 824 |           | Past.CentreLine, Past.List(_, list) -> List.map to_rc (get_centreline_cells list).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, None)
> File "bin/past_to_ast.ml", lines 818-824, characters 26-94:
> 818 | ..........................(match e with
> 819 |       | Past.List(_, es) -> (expand_list es vars)
> 820 |       | Past.Var(_) -> let (dt, Some ls) = safe_find e vars 
> 821 |         in match dt, ls with
> 822 |           | Past.Box, Past.List(_, list) -> list
> 823 |           | Past.Region, Past.List(_, list) -> list
> 824 |           | Past.CentreLine, Past.List(_, list) -> List.map to_rc (get_centreline_cells list))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
> Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 811-824, characters 5-94:
> 811 | .....match g with
> 812 |     | Past.Grid -> cell_grid l
> 813 |     | Past.Row(Some e) -> (match e with
> 814 |       | Past.Integer(_, i) -> List.map to_rc (row i)
> 815 |       | Past.Var(_) -> let (_, e1) = safe_find e vars 
> ...
> 821 |         in match dt, ls with
> 822 |           | Past.Box, Past.List(_, list) -> list
> 823 |           | Past.Region, Past.List(_, list) -> list
> 824 |           | Past.CentreLine, Past.List(_, list) -> List.map to_rc (get_centreline_cells list))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Row None|Regions|Universe|Column _|Boxes _)
> File "bin/past_to_ast.ml", lines 840-841, characters 21-57:
> 840 | .....................let (Ast.Var(v1), _) = translate_expr e vars in
> 841 |             (Ast.Var(sprintf "%s_%s" v2 v1)) :: (loop es)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", line 845, characters 8-96:
> 845 |         let (Ast.Var(v1), _) = translate_expr e1 vars in (Ast.Var(sprintf "%s_%s" v2 v1), vars2))
>               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", lines 833-845, characters 13-97:
> 833 | .............(let (Ast.Var(v2), vars2) = translate_expr e2 vars
> 834 |     in match e1 with
> 835 |       | Past.List(_, l) -> 
> 836 |         (let rec var_loop vars3 = function
> 837 |           | e::es -> let (_, vars1) = translate_expr e vars3 in var_loop vars1 es
> ...
> 842 |           | [] -> []
> 843 |         in (Ast.Bundle(loop l), var_loop vars2 l))
> 844 |       | _ -> 
> 845 |         let (Ast.Var(v1), _) = translate_expr e1 vars in (Ast.Var(sprintf "%s_%s" v2 v1), vars2))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", line 850, characters 55-123:
> 850 |                 (Ast.Boolean(List.mem (r, c) (List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> (r, c)) box)), vars)
>                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 849-850, characters 16-136:
> 849 | ................let (Past.List(_, [Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))])) = e1 in 
> 850 |                 (Ast.Boolean(List.mem (r, c) (List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> (r, c)) box)), vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (List (_, RC (_, Integer (_, _), Integer (_, _))::_::_)|
> List
>   (_,
>   RC
>     (_, Integer (_, _),
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)))::
>   _)|
> List
>   (_,
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _)::
>   _)|
> List
>   (_,
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _))::_)|
> List (_, [])|Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|
> Var (_, _)|Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
> Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|
> Group (_, _)|Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|
> CellDec (_, _)|ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 852-853, characters 28-106:
> 852 | ............................let Past.List(_, cells) = e1 in (Ast.MultiOp(Ast.And, List.map 
> 853 |               (fun rc -> let (r, c) = get_rc rc vars in Ast.Var(sprintf "%s_r%ic%i" v2 r c)) cells), vars).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 847-853, characters 31-107:
> 847 | ...............................(match safe_find e2 vars with
> 848 |             | (dt, Some (Past.List(_, box))) -> (if dt = Past.Box then 
> 849 |                 let (Past.List(_, [Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))])) = e1 in 
> 850 |                 (Ast.Boolean(List.mem (r, c) (List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> (r, c)) box)), vars)
> 851 |               else base)
> 852 |             | (dt, None) -> let Past.List(_, cells) = e1 in (Ast.MultiOp(Ast.And, List.map 
> 853 |               (fun rc -> let (r, c) = get_rc rc vars in Ast.Var(sprintf "%s_r%ic%i" v2 r c)) cells), vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_,
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 870-871, characters 66-42:
> 870 | ..................................................................(fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> 
> 871 |             Ast.Var(sprintf "r%ic%i" r c))...............
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 867-872, characters 67-22:
> 867 | ...................................................................(fun (dt, _, Some e) ->
> 868 |         match e with
> 869 |           | Past.List(_, ls) -> 
> 870 |             if dt = Past.Box then Some (Ast.MultiOp(con, List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> 
> 871 |             Ast.Var(sprintf "r%ic%i" r c)) ls)) else None
> 872 |           | _ -> None)..............
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, _, None)
> File "bin/past_to_ast.ml", lines 876-877, characters 46-44:
> 876 | ..............................................(fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> 
> 877 |               Ast.Var(sprintf "r%ic%i" r c))...............
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 873-878, characters 63-22:
> 873 | ...............................................................(fun (dt, _, Some e) ->
> 874 |         match e with
> 875 |           | Past.List(_, ls) -> if dt = Past.Region then 
> 876 |               Some (Ast.MultiOp(con, List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> 
> 877 |               Ast.Var(sprintf "r%ic%i" r c)) ls)) else None
> 878 |           | _ -> None)..............
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, _, None)
> File "bin/past_to_ast.ml", line 884, characters 12-103:
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars))
>                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 882-884, characters 8-113:
> 882 | ........match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars..
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 879-884, characters 29-114:
> 879 | .............................(
> 880 |         
> 881 |         let (_, Some e) = safe_find v vars in 
> 882 |         match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, None)
> File "bin/past_to_ast.ml", lines 863-884, characters 19-115:
> 863 | ...................(match g with
> 864 |       | Past.Grid -> (Ast.MultiOp(con, to_var (get_cells 0)), vars)
> 865 |       | Past.Row(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (rows ())), vars)
> 866 |       | Past.Column(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (columns ())), vars)
> 867 |       | Past.Boxes(None) -> (Ast.MultiOp(Ast.And, (List.filter_map (fun (dt, _, Some e) ->
> ...
> 881 |         let (_, Some e) = safe_find v vars in 
> 882 |         match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Row (Some _)|Column (Some _)|Boxes (Some _)|Universe)
> File "bin/past_to_ast.ml", lines 862-884, characters 5-115:
> 862 | .....match dt with
> 863 |     | Past.Cell -> (match g with
> 864 |       | Past.Grid -> (Ast.MultiOp(con, to_var (get_cells 0)), vars)
> 865 |       | Past.Row(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (rows ())), vars)
> 866 |       | Past.Column(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (columns ())), vars)
> ...
> 881 |         let (_, Some e) = safe_find v vars in 
> 882 |         match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Int|Bool|Region|CentreLine|EdgeLine|CentreLoop|EdgeLoop|Box)
> File "bin/past_to_ast.ml", lines 861-884, characters 5-115:
> 861 | .....let Past.Group(_, g) = e 
> 862 |   in match dt with
> 863 |     | Past.Cell -> (match g with
> 864 |       | Past.Grid -> (Ast.MultiOp(con, to_var (get_cells 0)), vars)
> 865 |       | Past.Row(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (rows ())), vars)
> ...
> 881 |         let (_, Some e) = safe_find v vars in 
> 882 |         match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 887-890, characters 2-102:
> 887 | ..match e with 
> 888 |     | Past.Range(_, Past.Integer(_, i1), Past.Integer(_, i2)) -> 
> 889 |       (Ast.Bundle(List.map (fun (r, c) -> Ast.Op(Ast.Op(Ast.Integer(i1), Ast.LTE, Ast.Var(sprintf "r%ic%i" r c)), 
> 890 |       Ast.And, Ast.Op(Ast.Var(sprintf "r%ic%i" r c), Ast.LTE, Ast.Integer(i2)))) (get_cells 0)), vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Range
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> Range
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Group (_, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 899-916, characters 2-51:
> 899 | ..match e with
> 900 |   | Past.Integer(_, n) -> (Ast.Integer(n), vars)
> 901 |   | Past.Boolean(_, b) -> (Ast.Boolean(b), vars)
> 902 |   | Past.RC(_, r, c) -> translate_rc r c vars
> 903 |   | Past.Var(_, v) -> (Ast.Var(v), vars)
> ...
> 913 |   | Past.Sugar(_, dt, e, c) -> translate_sugar dt e c vars 
> 914 |   | Past.CellDec(_, e) -> translate_celldec e vars
> 915 |   | Past.ITE(_, e1, e2, e3) -> translate_ite e1 e2 e3 vars
> 916 |   | Past.Group(_) -> raise (Err "Unexpected group")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Corner (_, _)|Range (_, _, _))
> File "bin/past_to_ast.ml", line 934, characters 13-120:
> 934 |     List.map (fun (_, Past.Var(_, v), _) -> Ast.ITE(Ast.Var(sprintf "%s_r%ic%i" v r c), Ast.Integer(1), Ast.Integer(0))) regions),
>                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_,
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)), _)
> File "bin/past_to_ast.ml", lines 952-954, characters 17-27:
> 952 | .................function
> 953 |     | [_] -> []
> 954 |     | x::xs -> x::(loop xs)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> []
> File "bin/past_to_ast.ml", line 957, characters 8-17:
> 957 | let rec init_vars l vars e uninit = 
>               ^^^^^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", line 16, characters 17-18:
> 16 |   | Past.Integer(l, _) -> raise (Err "int")
>                       ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 17, characters 17-18:
> 17 |   | Past.Boolean(l, _) -> raise (Err "bool")
>                       ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 18, characters 12-13:
> 18 |   | Past.RC(l, _, _) -> raise (Err "rc")
>                  ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 19, characters 13-14:
> 19 |   | Past.Var(l, _) -> raise (Err "var")
>                   ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 20, characters 12-13:
> 20 |   | Past.Op(l, _, _, _) -> raise (Err "op")
>                  ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 21, characters 17-18:
> 21 |   | Past.UnaryOp(l, _, _) -> raise (Err "unary")
>                       ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 22, characters 16-17:
> 22 |   | Past.SpecOp(l, _, _, _) -> raise (Err "spec")
>                      ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 23, characters 13-14:
> 23 |   | Past.Dec(l, _, _, _) -> raise (Err "dec")
>                   ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 24, characters 16-17:
> 24 |   | Past.Assign(l, _, _) -> raise (Err "assign")
>                      ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 25, characters 15-16:
> 25 |   | Past.Utils(l, _, _) -> raise (Err "utils")
>                     ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 26, characters 20-21:
> 26 |   | Past.Quantifier(l, _, _, _, _) -> raise (Err "quantifier")
>                          ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 27, characters 14-15:
> 27 |   | Past.List(l, _) -> raise (Err "list")
>                    ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 28, characters 15-16:
> 28 |   | Past.Group(l, _) -> raise (Err "group")
>                     ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 29, characters 15-16:
> 29 |   | Past.Range(l, _, _) -> raise (Err "range")
>                     ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 30, characters 16-17:
> 30 |   | Past.Member(l, _, _) -> raise (Err "member")
>                      ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 31, characters 15-16:
> 31 |   | Past.Sugar(l, _, _, _) -> raise (Err "sugar")
>                     ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 32, characters 17-18:
> 32 |   | Past.CellDec(l, _) -> raise (Err "celldec")
>                       ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 33, characters 13-14:
> 33 |   | Past.ITE(l, _, _, _) -> raise (Err "ite")
>                   ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 124, characters 20-21:
> 124 |       | Past.Var(_, v) -> let (_, x) = safe_find e2 vars
>                           ^
> Warning 27: unused variable v.
> File "bin/past_to_ast.ml", line 600, characters 20-24:
> 600 | let scan_utils expr vars =
>                           ^^^^
> Warning 27: unused variable vars.
> File "bin/past_to_ast.ml", line 615, characters 26-27:
> 615 |       | Past.Utils(_, e1, u) -> (match e1 with
>                                 ^
> Warning 27: unused variable u.
> File "bin/past_to_ast.ml", line 633, characters 11-15:
> 633 |     | var::vars -> List.concat_map (fun e -> List.map (fun (r, c) -> Past.Op(loc, Past.Var(loc, sprintf "%s_r%ic%i" var r c), Past.LeftImp,
>                  ^^^^
> Warning 27: unused variable vars.
> File "bin/past_to_ast.ml", line 727, characters 29-30:
> 727 |       | Some Past.Boolean(_, b) -> (Ast.Bundle([Ast.Dec(Ast.Bool, nv); nv]), (Past.Bool, v1, e)::vars)
>                                    ^
> Warning 27: unused variable b.
> File "bin/past_to_ast.ml", line 852, characters 15-17:
> 852 |             | (dt, None) -> let Past.List(_, cells) = e1 in (Ast.MultiOp(Ast.And, List.map 
>                      ^^
> Warning 27: unused variable dt.
> File "bin/past_to_ast.ml", line 971, characters 12-17:
> 971 |         let expr2 = replace_utils e uninit_group in   
>                   ^^^^^
> Warning 26: unused variable expr2.
> File "bin/past_to_ast.ml", line 988, characters 60-61:
> 988 |     in ((r, c), flatten ((find_reg vars)::List.map (fun (e, v) -> e) translated), vars)
>                                                                   ^
> Warning 27: unused variable v.
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Main.cmx -c -impl bin/main.ml)
$ (cd _build/default && /home/user/.opam/4.11.1/bin/ocamlopt.opt -w @1..3@5..28@31..39@43@46..47@49..57@61..62@67@69-40 -strict-sequence -strict-formats -short-paths -keep-locs -warn-error -A -g -I bin/.main.eobjs/byte -I bin/.main.eobjs/native -I /home/user/.opam/4.11.1/lib/base -I /home/user/.opam/4.11.1/lib/base/base_internalhash_types -I /home/user/.opam/4.11.1/lib/base/caml -I /home/user/.opam/4.11.1/lib/base/md5 -I /home/user/.opam/4.11.1/lib/base/shadow_stdlib -I /home/user/.opam/4.11.1/lib/base_bigstring -I /home/user/.opam/4.11.1/lib/base_quickcheck -I /home/user/.opam/4.11.1/lib/base_quickcheck/ppx_quickcheck/runtime -I /home/user/.opam/4.11.1/lib/bin_prot -I /home/user/.opam/4.11.1/lib/bin_prot/shape -I /home/user/.opam/4.11.1/lib/core -I /home/user/.opam/4.11.1/lib/core/base_for_tests -I /home/user/.opam/4.11.1/lib/core/validate -I /home/user/.opam/4.11.1/lib/core_kernel/caml_threads -I /home/user/.opam/4.11.1/lib/core_kernel/caml_unix -I /home/user/.opam/4.11.1/lib/core_kernel/flags -I /home/user/.opam/4.11.1/lib/core_unix -I /home/user/.opam/4.11.1/lib/core_unix/error_checking_mutex -I /home/user/.opam/4.11.1/lib/core_unix/signal_unix -I /home/user/.opam/4.11.1/lib/core_unix/sys_unix -I /home/user/.opam/4.11.1/lib/fieldslib -I /home/user/.opam/4.11.1/lib/int_repr -I /home/user/.opam/4.11.1/lib/jane-street-headers -I /home/user/.opam/4.11.1/lib/ocaml/threads -I /home/user/.opam/4.11.1/lib/parsexp -I /home/user/.opam/4.11.1/lib/ppx_assert/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_bench/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_compare/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_enumerate/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_expect/collector -I /home/user/.opam/4.11.1/lib/ppx_expect/common -I /home/user/.opam/4.11.1/lib/ppx_expect/config -I /home/user/.opam/4.11.1/lib/ppx_expect/config_types -I /home/user/.opam/4.11.1/lib/ppx_hash/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_here/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_inline_test/config -I /home/user/.opam/4.11.1/lib/ppx_inline_test/runtime-lib -I /home/user/.opam/4.11.1/lib/ppx_log/types -I /home/user/.opam/4.11.1/lib/ppx_module_timer/runtime -I /home/user/.opam/4.11.1/lib/ppx_sexp_conv/runtime-lib -I /home/user/.opam/4.11.1/lib/sexplib -I /home/user/.opam/4.11.1/lib/sexplib/unix -I /home/user/.opam/4.11.1/lib/sexplib0 -I /home/user/.opam/4.11.1/lib/spawn -I /home/user/.opam/4.11.1/lib/splittable_random -I /home/user/.opam/4.11.1/lib/stdio -I /home/user/.opam/4.11.1/lib/time_now -I /home/user/.opam/4.11.1/lib/typerep -I /home/user/.opam/4.11.1/lib/variantslib -intf-suffix .ml -no-alias-deps -opaque -open Dune__exe -o bin/.main.eobjs/native/dune__exe__Past_to_ast.cmx -c -impl bin/past_to_ast.ml)
> File "bin/past_to_ast.ml", lines 15-33, characters 21-45:
> 15 | .....................function
> 16 |   | Past.Integer(l, _) -> raise (Err "int")
> 17 |   | Past.Boolean(l, _) -> raise (Err "bool")
> 18 |   | Past.RC(l, _, _) -> raise (Err "rc")
> 19 |   | Past.Var(l, _) -> raise (Err "var")
> ...
> 30 |   | Past.Member(l, _, _) -> raise (Err "member")
> 31 |   | Past.Sugar(l, _, _, _) -> raise (Err "sugar")
> 32 |   | Past.CellDec(l, _) -> raise (Err "celldec")
> 33 |   | Past.ITE(l, _, _, _) -> raise (Err "ite")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Corner (_, _)
> File "bin/past_to_ast.ml", lines 57-75, characters 14-29:
> 57 | ..............function
> 58 |   | Past.Integer(l, _) -> l
> 59 |   | Past.Boolean(l, _) -> l
> 60 |   | Past.RC(l, _, _) -> l
> 61 |   | Past.Var(l, _) -> l
> ...
> 72 |   | Past.Member(l, _, _) -> l
> 73 |   | Past.Sugar(l, _, _, _) -> l
> 74 |   | Past.CellDec(l, _) -> l
> 75 |   | Past.ITE(l, _, _, _) -> l
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Corner (_, _)
> File "bin/past_to_ast.ml", line 104, characters 19-74:
> 104 |   | Past.Var(_) -> let (_, Some e2) = safe_find e vars in eval_num e2 vars 
>                          ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, None)
> File "bin/past_to_ast.ml", lines 111-113, characters 32-41:
> 111 | ................................(match uop with
> 112 |     | Past.Neg -> - eval_num e1 vars
> 113 |     | Past.Abs -> abs (eval_num e1 vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Not
> File "bin/past_to_ast.ml", lines 118-131, characters 20-31:
> 118 | ....................match e with
> 119 |   | Past.RC(_, r, c) -> 
> 120 |     let check_rc x limit = if 1 <= x && x <= limit then x else raise (Err "Invalid index")
> 121 |     in let f e2 limit =
> 122 |      match e2 with
> ...
> 128 |           | None -> raise (RegVar e2))
> 129 |       | Past.Corner(_, Past.Integer(_, i)) -> i
> 130 |       | _ -> eval_num e2 vars
> 131 |     in (f r !gridr, f c !gridc)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", line 133, characters 8-18:
> 133 | let rec substitute var_new var_old expr =
>               ^^^^^^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", lines 257-294, characters 2-167:
> 257 | ..let Ast.Var(nl) = l
> 258 |   in let (adj_lines, linevars) = create_linevars (x-1)
> 259 |   in let line_segments = List.concat_map (fun (rc1, rc2) -> [(rc1, rc2); (rc2, rc1)]) adj_lines
> 260 |   in let to_var (r1, c1) (r2, c2) = Ast.Var(sprintf "%s_r%i%sc%i%stor%i%sc%i%s" nl r1 s c1 s r2 s c2 s )
> 261 |   in let to_cell (r, c) ss = Ast.Var(sprintf "%s_r%i%sc%i%s%s" nl r s c s ss)
> ...
> 291 |     @ (if line then [] else List.map (fun rc1 -> Ast.Op(to_cell rc1 "_sink", Ast.LeftImp, Ast.UnaryOp(Ast.Not, Ast.MultiOp(Ast.Or, 
> 292 |       List.map (fun rc2 -> to_var rc1 rc2) (surrounding x rc1))))) cells)
> 293 |     @ (if line then [] else List.map (fun rc1 -> Ast.Op(Ast.Op(Ast.UnaryOp(Ast.Not, to_cell rc1 "_source"), Ast.And, to_cell rc1 ""), Ast.LeftImp, 
> 294 |       Ast.Op(Ast.MultiOp(Ast.Add, List.map (fun rc2 -> Ast.ITE(to_var rc2 rc1, Ast.Integer(1), Ast.Integer(0))) (surrounding x rc1)), Ast.GTE, Ast.Integer(1)))) cells)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
> Dec (_, _)|Bundle _|ITE (_, _, _))
> File "bin/past_to_ast.ml", line 317, characters 10-28:
> 317 |   let rec parent_constraints r c =
>                 ^^^^^^^^^^^^^^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", lines 464-466, characters 2-70:
> 464 | ..let Past.Var(_, v1) = nv in
> 465 |   let (lines, nvars) = translate_centreline l v1 vars
> 466 |   in (Ast.Bundle(init@lines), (Past.CentreLine, nv, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 469-471, characters 2-68:
> 469 | ..let Past.Var(_, v1) = nv in
> 470 |   let (lines, nvars) = translate_edgeline l v1 vars
> 471 |   in (Ast.Bundle(init@lines), (Past.EdgeLine, nv, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 474-476, characters 2-70:
> 474 | ..let Past.Var(_, v1) = nv in
> 475 |   let (lines, nvars) = translate_centreline l v1 vars
> 476 |   in (Ast.Bundle(init@lines), (Past.CentreLoop, nv, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 479-481, characters 2-68:
> 479 | ..let Past.Var(_, v1) = nv in
> 480 |   let (lines, nvars) = translate_edgeline l v1 vars
> 481 |   in (Ast.Bundle(init@lines), (Past.EdgeLoop, nv, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 486-489, characters 17-14:
> 486 | .................function
> 487 |     | Past.Range(_, Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)), Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)))::cs -> 
> 488 |       [(r1, c1); (r2, c2)]@(loop cs)
> 489 |     | [] -> []
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Range
>    (_, RC (_, Integer (_, _), Integer (_, _)),
>    RC
>      (_, Integer (_, _),
>      (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>      UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>      Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>      Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>      ITE (_, _, _, _))))::
>  _|
> Range
>   (_, RC (_, Integer (_, _), Integer (_, _)),
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _))::
> _|
> Range
>   (_, RC (_, Integer (_, _), Integer (_, _)),
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))::
> _|
> Range
>   (_,
>   RC
>     (_, Integer (_, _),
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _))),
>   _)::
> _|
> Range
>   (_,
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _),
>   _)::
> _|
> Range
>   (_,
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)::
> _|
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Group (_, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))::_)
> File "bin/past_to_ast.ml", line 581, characters 46-140:
> 581 |         | Past.Quantifier(l, q, e1, g, e2) -> let Past.Group(_, ng) = loop (Past.Group(l, g)) in Past.Quantifier(l, q, loop e1, ng, loop e2)
>                                                     ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", line 632, characters 13-18:
> 632 |   in let rec loop2 ls = function
>                    ^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", line 629, characters 8-21:
> 629 | let rec replace_utils expr vs = 
>               ^^^^^^^^^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", line 674, characters 27-118:
> 674 |     | Past.Var(_, _), _ -> let Past.SpecOp(_, _, nsop, _) = replace_spec_op (Past.SpecOp(l, e1, sop, e2)) vars in nsop
>                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", line 675, characters 27-118:
> 675 |     | _, Past.Var(_, _) -> let Past.SpecOp(_, _, nsop, _) = replace_spec_op (Past.SpecOp(l, e1, sop, e2)) vars in nsop
>                                  ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 681-683, characters 6-110:
> 681 | ......let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 682 |       ((if (abs (r1-r2) + abs (c1-c2)) = 1 then 
> 683 |       Ast.Op(Ast.Var(sprintf "%s_root" v1), Ast.Unequal, Ast.Var(sprintf "%s_root" v2)) else Ast.Dead), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 680-683, characters 29-110:
> 680 | .............................let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 681 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 682 |       ((if (abs (r1-r2) + abs (c1-c2)) = 1 then 
> 683 |       Ast.Op(Ast.Var(sprintf "%s_root" v1), Ast.Unequal, Ast.Var(sprintf "%s_root" v2)) else Ast.Dead), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 685-686, characters 6-128:
> 685 | ......let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 686 |       ((if (abs (r1-r2) <= 1 && abs(c1-c2) <= 1 && (r1, c1) <> (r2, c2)) then Ast.Boolean(true) else Ast.Boolean(false)), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 684-686, characters 27-128:
> 684 | ...........................let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 685 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 686 |       ((if (abs (r1-r2) <= 1 && abs(c1-c2) <= 1 && (r1, c1) <> (r2, c2)) then Ast.Boolean(true) else Ast.Boolean(false)), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 688-689, characters 6-97:
> 688 | ......let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 689 |       ((if (abs (r1-r2) + abs(c1-c2)) = 1 then Ast.Boolean(true) else Ast.Boolean(false)), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 687-689, characters 27-97:
> 687 | ...........................let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 688 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 689 |       ((if (abs (r1-r2) + abs(c1-c2)) = 1 then Ast.Boolean(true) else Ast.Boolean(false)), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 695-700, characters 24-34:
> 695 | ........................function
> 696 |         | Past.Range(_, Past.RC(_, Past.Integer(_, ra1), Past.Integer(_, ca1)), 
> 697 |           Past.RC(_, Past.Integer(_, ra2), Past.Integer(_, ca2)))::es -> 
> 698 |           if (r1, c1, r2, c2) = (ra1, ca1, ra2, ca2) || (r1, c1, r2, c2) = (ra2, ca2, ra1, ca1)
> 699 |           then Ast.Boolean(true) else loop es
> 700 |         | [] -> Ast.Boolean(false)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Range
>    (_, RC (_, Integer (_, _), Integer (_, _)),
>    RC
>      (_, Integer (_, _),
>      (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>      UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>      Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>      Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>      ITE (_, _, _, _))))::
>  _|
> Range
>   (_, RC (_, Integer (_, _), Integer (_, _)),
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _))::
> _|
> Range
>   (_, RC (_, Integer (_, _), Integer (_, _)),
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))::
> _|
> Range
>   (_,
>   RC
>     (_, Integer (_, _),
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _))),
>   _)::
> _|
> Range
>   (_,
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _),
>   _)::
> _|
> Range
>   (_,
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)::
> _|
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Group (_, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))::_)
> File "bin/past_to_ast.ml", lines 694-701, characters 6-16:
> 694 | ......let (_, Some (Past.List(_, ls))) = safe_find v vars 
> 695 |       in let rec loop = function
> 696 |         | Past.Range(_, Past.RC(_, Past.Integer(_, ra1), Past.Integer(_, ca1)), 
> 697 |           Past.RC(_, Past.Integer(_, ra2), Past.Integer(_, ca2)))::es -> 
> 698 |           if (r1, c1, r2, c2) = (ra1, ca1, ra2, ca2) || (r1, c1, r2, c2) = (ra2, ca2, ra1, ca1)
> 699 |           then Ast.Boolean(true) else loop es
> 700 |         | [] -> Ast.Boolean(false)
> 701 |       in loop ls.......................
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((_,
>  Some
>    (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>    Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>    Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> (_, None))
> File "bin/past_to_ast.ml", lines 692-701, characters 6-39:
> 692 | ......let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 693 |       ((if abs (r1-r2) <= 1 && abs (c1-c2) <= 1 then
> 694 |       let (_, Some (Past.List(_, ls))) = safe_find v vars 
> 695 |       in let rec loop = function
> 696 |         | Past.Range(_, Past.RC(_, Past.Integer(_, ra1), Past.Integer(_, ca1)), 
> 697 |           Past.RC(_, Past.Integer(_, ra2), Past.Integer(_, ca2)))::es -> 
> 698 |           if (r1, c1, r2, c2) = (ra1, ca1, ra2, ca2) || (r1, c1, r2, c2) = (ra2, ca2, ra1, ca1)
> 699 |           then Ast.Boolean(true) else loop es
> 700 |         | [] -> Ast.Boolean(false)
> 701 |       in loop ls else Ast.Dead), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 691-701, characters 6-39:
> 691 | ......let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 692 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 693 |       ((if abs (r1-r2) <= 1 && abs (c1-c2) <= 1 then
> 694 |       let (_, Some (Past.List(_, ls))) = safe_find v vars 
> 695 |       in let rec loop = function
> ...
> 698 |           if (r1, c1, r2, c2) = (ra1, ca1, ra2, ca2) || (r1, c1, r2, c2) = (ra2, ca2, ra1, ca1)
> 699 |           then Ast.Boolean(true) else loop es
> 700 |         | [] -> Ast.Boolean(false)
> 701 |       in loop ls else Ast.Dead), vars2)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 713-715, characters 10-99:
> 713 | ..........(match e1, e2 with
> 714 |         | Past.Var(_, v), Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)) -> num_constr r c v n
> 715 |         | Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)), Past.Var(_, v) -> num_constr r c v n)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((RC (_, Integer (_, _), Integer (_, _)),
>  (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
>  UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>  Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>  Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>  ITE (_, _, _, _)))|
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _))),
> _)|
> (RC
>    (_,
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)), _),
> _)|
> (Var (_, _),
> RC
>   (_, Integer (_, _),
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _))))|
> (Var (_, _),
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _))|
> (Var (_, _),
> (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)))|
> ((Integer (_, _)|Boolean (_, _)|Corner (_, _)|Op (_, _, _, _)|
>  UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>  Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>  Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>  ITE (_, _, _, _)),
> _))
> File "bin/past_to_ast.ml", lines 678-717, characters 2-69:
> 678 | ..let (Ast.Var(v2), vars2) = translate_expr e2 vars1 in
> 679 |   match sop1 with
> 680 |     | Past.RegionAdjacent -> let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 681 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> 682 |       ((if (abs (r1-r2) + abs (c1-c2)) = 1 then 
> ...
> 714 |         | Past.Var(_, v), Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)) -> num_constr r c v n
> 715 |         | Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)), Past.Var(_, v) -> num_constr r c v n)
> 716 |         , vars2)
> 717 |     | Past.Adjacent(_) -> raise (Err "Adj operation not substituted")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", lines 677-717, characters 5-69:
> 677 | .....let (Ast.Var(v1), vars1) = translate_expr e1 vars in
> 678 |   let (Ast.Var(v2), vars2) = translate_expr e2 vars1 in
> 679 |   match sop1 with
> 680 |     | Past.RegionAdjacent -> let Past.RC(_, Past.Integer(_, r1), Past.Integer(_, c1)) = e1 in 
> 681 |       let Past.RC(_, Past.Integer(_, r2), Past.Integer(_, c2)) = e2 in
> ...
> 714 |         | Past.Var(_, v), Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)) -> num_constr r c v n
> 715 |         | Past.RC(_, Past.Integer(_, r), Past.Integer(_, c)), Past.Var(_, v) -> num_constr r c v n)
> 716 |         , vars2)
> 717 |     | Past.Adjacent(_) -> raise (Err "Adj operation not substituted")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", lines 723-725, characters 18-67:
> 723 | ..................(match e with
> 724 |       | Some Past.Integer(_, i) -> (Ast.Bundle([Ast.Dec(Ast.Int, nv); Ast.Op(nv, Ast.Equal, Ast.Integer(i))]), (Past.Int, v1, e)::vars)
> 725 |       | None -> (Ast.Dec(Ast.Int, nv), (Past.Int, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Some
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 726-728, characters 19-69:
> 726 | ...................(match e with
> 727 |       | Some Past.Boolean(_, b) -> (Ast.Bundle([Ast.Dec(Ast.Bool, nv); nv]), (Past.Bool, v1, e)::vars)
> 728 |       | None -> (Ast.Dec(Ast.Bool, nv), (Past.Bool, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Some
>   (Integer (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 729-730, characters 19-56:
> 729 | ...................(match e with 
> 730 |       | None -> (Ast.Dead, (Past.Cell, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> Some _
> File "bin/past_to_ast.ml", lines 732-736, characters 6-66:
> 732 | ......(match e with
> 733 |       | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_region l init v1 vars
> 734 |       | Some Past.Var(l, v2) -> let (dt, expr) = safe_find (Past.Var(l, v2)) vars 
> 735 |         in (Ast.Dead, (dt, (Past.Var(l, v2)), expr)::vars)
> 736 |       | None -> (Ast.Bundle(init), (Past.Region, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Range (_, _, _)|
>   Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 738-740, characters 6-70:
> 738 | ......(match e with
> 739 |       | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_centreline l init v1 vars
> 740 |       | None -> (Ast.Bundle(init), (Past.CentreLine, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 742-744, characters 6-70:
> 742 | ......(match e with
> 743 |         | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_edgeline l init v1 vars
> 744 |         | None -> (Ast.Bundle(init), (Past.EdgeLine, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 746-748, characters 6-70:
> 746 | ......(match e with
> 747 |       | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_centreloop l init v1 vars(*fix*)
> 748 |       | None -> (Ast.Bundle(init), (Past.CentreLine, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 750-752, characters 6-70:
> 750 | ......(match e with
> 751 |       | Some Past.Group(_, Past.Instance(Past.List(_, l))) -> define_edgeloop l init v1 vars(*fix*)
> 752 |       | None -> (Ast.Bundle(init), (Past.CentreLine, v1, None)::vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Group
>       (_,
>       Instance
>         (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>         Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
>         Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
>         Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
>         Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))))|
> Some (Group (_, (Grid|Regions|Universe|Row _|Column _|Boxes _)))|
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", line 756, characters 6-7:
> 756 |     | _ -> raise (Err "Unimplemented datatype")
>             ^
> Warning 11: this match case is unused.
> File "bin/past_to_ast.ml", line 760, characters 6-9:
> 760 |     | [v] -> [helper v vars]
>             ^^^
> Warning 11: this match case is unused.
> File "bin/past_to_ast.ml", lines 762-764, characters 5-88:
> 762 | .....match v with 
> 763 |     | Past.List(_, l) -> let nl = loop vars l in
> 764 |       let (es, vs) = List.split nl in (Ast.Bundle(es), List.nth vs ((List.length vs)-1))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", line 769, characters 21-73:
> 769 |     | Past.Region -> let Past.List(_, l) = e in define_region l [] v vars
>                            ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 770-772, characters 25-67:
> 770 | .........................let Past.List(_, l) = e in 
> 771 |       let (line, nvars) = translate_centreline l (get_var v) vars
> 772 |       in (Ast.Bundle(line), (Past.CentreLine, v, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 768-772, characters 5-67:
> 768 | .....match dt with
> 769 |     | Past.Region -> let Past.List(_, l) = e in define_region l [] v vars
> 770 |     | Past.CentreLine -> let Past.List(_, l) = e in 
> 771 |       let (line, nvars) = translate_centreline l (get_var v) vars
> 772 |       in (Ast.Bundle(line), (Past.CentreLine, v, Some nvars)::vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Int|Bool|Cell|EdgeLine|CentreLoop|EdgeLoop|Box)
> File "bin/past_to_ast.ml", lines 775-780, characters 2-63:
> 775 | ..match u with
> 776 |     | Past.Size -> (match e with
> 777 |       | Past.Utils(_, e1, Past.Reg) -> translate_utils e1 u vars
> 778 |       | _ -> (Ast.Var(sprintf "%s_size" (get_var e)), vars))
> 779 |     | Past.Reg -> (Ast.Var(sprintf "%s_root" (get_var e)), vars)
> 780 |     | Past.Sum -> (Ast.Var(sprintf "%s_sum" (get_var e)), vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Cells|Value|Length)
> File "bin/past_to_ast.ml", lines 786-788, characters 20-31:
> 786 | ....................match q with
> 787 |         | Past.ForAll -> Ast.And
> 788 |         | Past.Exists -> Ast.Or
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (NForAll|NExists)
> File "bin/past_to_ast.ml", lines 793-797, characters 10-15:
> 793 | ..........let Past.Dec(_, dt, _, _) = d in
> 794 |           let (nv, _) = translate_quantifier l q (Past.Dec(l, Past.Cell, Past.List(l, vs), None)) ng
> 795 |             (Past.Quantifier(l, q, (Past.Dec(l, Past.Cell, Past.List(l, [vx]), None)), ng,
> 796 |             replace_spec_op c (store_vars dt vars ls))) vars
> 797 |           in nv
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 789-797, characters 33-15:
> 789 | .................................match ls with
> 790 |         | [vx] -> Ast.MultiOp(op, List.map (fun rc -> let (expr, _) = 
> 791 |           translate_expr (substitute rc (get_var vx) c) vars in expr) group)
> 792 |         | vx::vs ->
> 793 |           let Past.Dec(_, dt, _, _) = d in
> 794 |           let (nv, _) = translate_quantifier l q (Past.Dec(l, Past.Cell, Past.List(l, vs), None)) ng
> 795 |             (Past.Quantifier(l, q, (Past.Dec(l, Past.Cell, Past.List(l, [vx]), None)), ng,
> 796 |             replace_spec_op c (store_vars dt vars ls))) vars
> 797 |           in nv
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> []
> File "bin/past_to_ast.ml", lines 798-807, characters 9-64:
> 798 | .........match d with
> 799 |         | Past.Dec(_, Past.Cell, Past.List(_, ls), _) -> 
> 800 |           (match g with
> 801 |             | Past.Row(Some (Past.Var(_, v))) -> (Ast.MultiOp(Or, (List.mapi (fun i -> fun group -> 
> 802 |                 Ast.Op(Ast.Op(Ast.Var(v), Ast.Equal, Ast.Integer(!gridr-i)), Ast.And, split group (Past.Row(Some (Past.Integer(l, !gridr-i)))) ls)) 
> 803 |                 (List.map (fun lss -> List.map (fun (r, c) -> Past.RC(l, Past.Integer(l, r), Past.Integer(l, c))) lss) (rows ())))), vars)
> 804 |             | _ -> (split (translate_group l g vars) g ls, vars))
> 805 |         | Past.Dec(_, Past.Region, Past.List(_, ls), _) ->
> 806 |           let (reg, _) = translate_expr d vars 
> 807 |           in (Ast.Bundle(reg::[split (cell_grid l) g ls]), vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Dec
>    (_, Cell,
>    (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>    Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>    Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)), _)|
> Dec
>   (_, Region,
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Dec (_, (Int|Bool|CentreLine|EdgeLine|CentreLoop|EdgeLoop|Box), _, _)|
> Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 816-817, characters 11-61:
> 816 | ...........match e1 with
> 817 |         | Some (Past.Integer(_, i)) -> List.map to_rc (row i).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Some
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _))|
> None)
> File "bin/past_to_ast.ml", lines 813-817, characters 26-62:
> 813 | ..........................(match e with
> 814 |       | Past.Integer(_, i) -> List.map to_rc (row i)
> 815 |       | Past.Var(_) -> let (_, e1) = safe_find e vars 
> 816 |         in match e1 with
> 817 |         | Some (Past.Integer(_, i)) -> List.map to_rc (row i))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|UnaryOp (_, _, _)|
> SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|
> Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|Range (_, _, _)|
> Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 821-824, characters 11-93:
> 821 | ...........match dt, ls with
> 822 |           | Past.Box, Past.List(_, list) -> list
> 823 |           | Past.Region, Past.List(_, list) -> list
> 824 |           | Past.CentreLine, Past.List(_, list) -> List.map to_rc (get_centreline_cells list).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((CentreLine,
>  (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>  Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>  Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>  Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>  ITE (_, _, _, _)))|
> (Region,
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)))|
> (Box,
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)))|((Int|Bool|Cell|EdgeLine|CentreLoop|EdgeLoop), _))
> File "bin/past_to_ast.ml", lines 820-824, characters 23-93:
> 820 | .......................let (dt, Some ls) = safe_find e vars 
> 821 |         in match dt, ls with
> 822 |           | Past.Box, Past.List(_, list) -> list
> 823 |           | Past.Region, Past.List(_, list) -> list
> 824 |           | Past.CentreLine, Past.List(_, list) -> List.map to_rc (get_centreline_cells list).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, None)
> File "bin/past_to_ast.ml", lines 818-824, characters 26-94:
> 818 | ..........................(match e with
> 819 |       | Past.List(_, es) -> (expand_list es vars)
> 820 |       | Past.Var(_) -> let (dt, Some ls) = safe_find e vars 
> 821 |         in match dt, ls with
> 822 |           | Past.Box, Past.List(_, list) -> list
> 823 |           | Past.Region, Past.List(_, list) -> list
> 824 |           | Past.CentreLine, Past.List(_, list) -> List.map to_rc (get_centreline_cells list))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|Range (_, _, _)|
> Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 811-824, characters 5-94:
> 811 | .....match g with
> 812 |     | Past.Grid -> cell_grid l
> 813 |     | Past.Row(Some e) -> (match e with
> 814 |       | Past.Integer(_, i) -> List.map to_rc (row i)
> 815 |       | Past.Var(_) -> let (_, e1) = safe_find e vars 
> ...
> 821 |         in match dt, ls with
> 822 |           | Past.Box, Past.List(_, list) -> list
> 823 |           | Past.Region, Past.List(_, list) -> list
> 824 |           | Past.CentreLine, Past.List(_, list) -> List.map to_rc (get_centreline_cells list))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Row None|Regions|Universe|Column _|Boxes _)
> File "bin/past_to_ast.ml", lines 840-841, characters 21-57:
> 840 | .....................let (Ast.Var(v1), _) = translate_expr e vars in
> 841 |             (Ast.Var(sprintf "%s_%s" v2 v1)) :: (loop es)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", line 845, characters 8-96:
> 845 |         let (Ast.Var(v1), _) = translate_expr e1 vars in (Ast.Var(sprintf "%s_%s" v2 v1), vars2))
>               ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", lines 833-845, characters 13-97:
> 833 | .............(let (Ast.Var(v2), vars2) = translate_expr e2 vars
> 834 |     in match e1 with
> 835 |       | Past.List(_, l) -> 
> 836 |         (let rec var_loop vars3 = function
> 837 |           | e::es -> let (_, vars1) = translate_expr e vars3 in var_loop vars1 es
> ...
> 842 |           | [] -> []
> 843 |         in (Ast.Bundle(loop l), var_loop vars2 l))
> 844 |       | _ -> 
> 845 |         let (Ast.Var(v1), _) = translate_expr e1 vars in (Ast.Var(sprintf "%s_%s" v2 v1), vars2))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> ((Dead|Integer _|Boolean _|Op (_, _, _)|UnaryOp (_, _)|MultiOp (_, _)|
>  Dec (_, _)|Bundle _|ITE (_, _, _)),
> _)
> File "bin/past_to_ast.ml", line 850, characters 55-123:
> 850 |                 (Ast.Boolean(List.mem (r, c) (List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> (r, c)) box)), vars)
>                                                              ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 849-850, characters 16-136:
> 849 | ................let (Past.List(_, [Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))])) = e1 in 
> 850 |                 (Ast.Boolean(List.mem (r, c) (List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> (r, c)) box)), vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (List (_, RC (_, Integer (_, _), Integer (_, _))::_::_)|
> List
>   (_,
>   RC
>     (_, Integer (_, _),
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)))::
>   _)|
> List
>   (_,
>   RC
>     (_,
>     (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>     UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>     Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>     Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>     ITE (_, _, _, _)), _)::
>   _)|
> List
>   (_,
>   (Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _))::_)|
> List (_, [])|Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|
> Var (_, _)|Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|
> Dec (_, _, _, _)|Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|
> Group (_, _)|Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|
> CellDec (_, _)|ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 852-853, characters 28-106:
> 852 | ............................let Past.List(_, cells) = e1 in (Ast.MultiOp(Ast.And, List.map 
> 853 |               (fun rc -> let (r, c) = get_rc rc vars in Ast.Var(sprintf "%s_r%ic%i" v2 r c)) cells), vars).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 847-853, characters 31-107:
> 847 | ...............................(match safe_find e2 vars with
> 848 |             | (dt, Some (Past.List(_, box))) -> (if dt = Past.Box then 
> 849 |                 let (Past.List(_, [Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))])) = e1 in 
> 850 |                 (Ast.Boolean(List.mem (r, c) (List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> (r, c)) box)), vars)
> 851 |               else base)
> 852 |             | (dt, None) -> let Past.List(_, cells) = e1 in (Ast.MultiOp(Ast.And, List.map 
> 853 |               (fun rc -> let (r, c) = get_rc rc vars in Ast.Var(sprintf "%s_r%ic%i" v2 r c)) cells), vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_,
> Some
>   (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
>   Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
>   Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)))
> File "bin/past_to_ast.ml", lines 870-871, characters 66-42:
> 870 | ..................................................................(fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> 
> 871 |             Ast.Var(sprintf "r%ic%i" r c))...............
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 867-872, characters 67-22:
> 867 | ...................................................................(fun (dt, _, Some e) ->
> 868 |         match e with
> 869 |           | Past.List(_, ls) -> 
> 870 |             if dt = Past.Box then Some (Ast.MultiOp(con, List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> 
> 871 |             Ast.Var(sprintf "r%ic%i" r c)) ls)) else None
> 872 |           | _ -> None)..............
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, _, None)
> File "bin/past_to_ast.ml", lines 876-877, characters 46-44:
> 876 | ..............................................(fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> 
> 877 |               Ast.Var(sprintf "r%ic%i" r c))...............
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 873-878, characters 63-22:
> 873 | ...............................................................(fun (dt, _, Some e) ->
> 874 |         match e with
> 875 |           | Past.List(_, ls) -> if dt = Past.Region then 
> 876 |               Some (Ast.MultiOp(con, List.map (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> 
> 877 |               Ast.Var(sprintf "r%ic%i" r c)) ls)) else None
> 878 |           | _ -> None)..............
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, _, None)
> File "bin/past_to_ast.ml", line 884, characters 12-103:
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars))
>                   ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (RC
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> RC
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 882-884, characters 8-113:
> 882 | ........match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars..
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 879-884, characters 29-114:
> 879 | .............................(
> 880 |         
> 881 |         let (_, Some e) = safe_find v vars in 
> 882 |         match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars).
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_, None)
> File "bin/past_to_ast.ml", lines 863-884, characters 19-115:
> 863 | ...................(match g with
> 864 |       | Past.Grid -> (Ast.MultiOp(con, to_var (get_cells 0)), vars)
> 865 |       | Past.Row(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (rows ())), vars)
> 866 |       | Past.Column(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (columns ())), vars)
> 867 |       | Past.Boxes(None) -> (Ast.MultiOp(Ast.And, (List.filter_map (fun (dt, _, Some e) ->
> ...
> 881 |         let (_, Some e) = safe_find v vars in 
> 882 |         match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Row (Some _)|Column (Some _)|Boxes (Some _)|Universe)
> File "bin/past_to_ast.ml", lines 862-884, characters 5-115:
> 862 | .....match dt with
> 863 |     | Past.Cell -> (match g with
> 864 |       | Past.Grid -> (Ast.MultiOp(con, to_var (get_cells 0)), vars)
> 865 |       | Past.Row(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (rows ())), vars)
> 866 |       | Past.Column(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (columns ())), vars)
> ...
> 881 |         let (_, Some e) = safe_find v vars in 
> 882 |         match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Int|Bool|Region|CentreLine|EdgeLine|CentreLoop|EdgeLoop|Box)
> File "bin/past_to_ast.ml", lines 861-884, characters 5-115:
> 861 | .....let Past.Group(_, g) = e 
> 862 |   in match dt with
> 863 |     | Past.Cell -> (match g with
> 864 |       | Past.Grid -> (Ast.MultiOp(con, to_var (get_cells 0)), vars)
> 865 |       | Past.Row(None) -> (Ast.MultiOp(Ast.And, List.map (fun l -> Ast.MultiOp(con, to_var l)) (rows ())), vars)
> ...
> 881 |         let (_, Some e) = safe_find v vars in 
> 882 |         match e with
> 883 |           | Past.List(_, ls) -> Ast.MultiOp(Ast.Unequal, List.map 
> 884 |             (fun (Past.RC(_, Past.Integer(_, r), Past.Integer(_, c))) -> Ast.Var(sprintf "r%ic%i" r c)) ls), vars))
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 887-890, characters 2-102:
> 887 | ..match e with 
> 888 |     | Past.Range(_, Past.Integer(_, i1), Past.Integer(_, i2)) -> 
> 889 |       (Ast.Bundle(List.map (fun (r, c) -> Ast.Op(Ast.Op(Ast.Integer(i1), Ast.LTE, Ast.Var(sprintf "r%ic%i" r c)), 
> 890 |       Ast.And, Ast.Op(Ast.Var(sprintf "r%ic%i" r c), Ast.LTE, Ast.Integer(i2)))) (get_cells 0)), vars)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Range
>    (_, Integer (_, _),
>    (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>    UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>    Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>    Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>    ITE (_, _, _, _)))|
> Range
>   (_,
>   (Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|Op (_, _, _, _)|
>   UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
>   Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
>   Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
>   ITE (_, _, _, _)), _)|
> Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Var (_, _)|
> Op (_, _, _, _)|UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|
> Assign (_, _, _)|Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|
> Group (_, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _))
> File "bin/past_to_ast.ml", lines 899-916, characters 2-51:
> 899 | ..match e with
> 900 |   | Past.Integer(_, n) -> (Ast.Integer(n), vars)
> 901 |   | Past.Boolean(_, b) -> (Ast.Boolean(b), vars)
> 902 |   | Past.RC(_, r, c) -> translate_rc r c vars
> 903 |   | Past.Var(_, v) -> (Ast.Var(v), vars)
> ...
> 913 |   | Past.Sugar(_, dt, e, c) -> translate_sugar dt e c vars 
> 914 |   | Past.CellDec(_, e) -> translate_celldec e vars
> 915 |   | Past.ITE(_, e1, e2, e3) -> translate_ite e1 e2 e3 vars
> 916 |   | Past.Group(_) -> raise (Err "Unexpected group")
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (Corner (_, _)|Range (_, _, _))
> File "bin/past_to_ast.ml", line 934, characters 13-120:
> 934 |     List.map (fun (_, Past.Var(_, v), _) -> Ast.ITE(Ast.Var(sprintf "%s_r%ic%i" v r c), Ast.Integer(1), Ast.Integer(0))) regions),
>                    ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> (_,
> (Integer (_, _)|Boolean (_, _)|RC (_, _, _)|Corner (_, _)|Op (_, _, _, _)|
> UnaryOp (_, _, _)|SpecOp (_, _, _, _)|Dec (_, _, _, _)|Assign (_, _, _)|
> Utils (_, _, _)|Quantifier (_, _, _, _, _)|List (_, _)|Group (_, _)|
> Range (_, _, _)|Member (_, _, _)|Sugar (_, _, _, _)|CellDec (_, _)|
> ITE (_, _, _, _)), _)
> File "bin/past_to_ast.ml", lines 952-954, characters 17-27:
> 952 | .................function
> 953 |     | [_] -> []
> 954 |     | x::xs -> x::(loop xs)
> Warning 8: this pattern-matching is not exhaustive.
> Here is an example of a case that is not matched:
> []
> File "bin/past_to_ast.ml", line 957, characters 8-17:
> 957 | let rec init_vars l vars e uninit = 
>               ^^^^^^^^^
> Warning 39: unused rec flag.
> File "bin/past_to_ast.ml", line 16, characters 17-18:
> 16 |   | Past.Integer(l, _) -> raise (Err "int")
>                       ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 17, characters 17-18:
> 17 |   | Past.Boolean(l, _) -> raise (Err "bool")
>                       ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 18, characters 12-13:
> 18 |   | Past.RC(l, _, _) -> raise (Err "rc")
>                  ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 19, characters 13-14:
> 19 |   | Past.Var(l, _) -> raise (Err "var")
>                   ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 20, characters 12-13:
> 20 |   | Past.Op(l, _, _, _) -> raise (Err "op")
>                  ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 21, characters 17-18:
> 21 |   | Past.UnaryOp(l, _, _) -> raise (Err "unary")
>                       ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 22, characters 16-17:
> 22 |   | Past.SpecOp(l, _, _, _) -> raise (Err "spec")
>                      ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 23, characters 13-14:
> 23 |   | Past.Dec(l, _, _, _) -> raise (Err "dec")
>                   ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 24, characters 16-17:
> 24 |   | Past.Assign(l, _, _) -> raise (Err "assign")
>                      ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 25, characters 15-16:
> 25 |   | Past.Utils(l, _, _) -> raise (Err "utils")
>                     ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 26, characters 20-21:
> 26 |   | Past.Quantifier(l, _, _, _, _) -> raise (Err "quantifier")
>                          ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 27, characters 14-15:
> 27 |   | Past.List(l, _) -> raise (Err "list")
>                    ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 28, characters 15-16:
> 28 |   | Past.Group(l, _) -> raise (Err "group")
>                     ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 29, characters 15-16:
> 29 |   | Past.Range(l, _, _) -> raise (Err "range")
>                     ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 30, characters 16-17:
> 30 |   | Past.Member(l, _, _) -> raise (Err "member")
>                      ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 31, characters 15-16:
> 31 |   | Past.Sugar(l, _, _, _) -> raise (Err "sugar")
>                     ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 32, characters 17-18:
> 32 |   | Past.CellDec(l, _) -> raise (Err "celldec")
>                       ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 33, characters 13-14:
> 33 |   | Past.ITE(l, _, _, _) -> raise (Err "ite")
>                   ^
> Warning 27: unused variable l.
> File "bin/past_to_ast.ml", line 124, characters 20-21:
> 124 |       | Past.Var(_, v) -> let (_, x) = safe_find e2 vars
>                           ^
> Warning 27: unused variable v.
> File "bin/past_to_ast.ml", line 600, characters 20-24:
> 600 | let scan_utils expr vars =
>                           ^^^^
> Warning 27: unused variable vars.
> File "bin/past_to_ast.ml", line 615, characters 26-27:
> 615 |       | Past.Utils(_, e1, u) -> (match e1 with
>                                 ^
> Warning 27: unused variable u.
> File "bin/past_to_ast.ml", line 633, characters 11-15:
> 633 |     | var::vars -> List.concat_map (fun e -> List.map (fun (r, c) -> Past.Op(loc, Past.Var(loc, sprintf "%s_r%ic%i" var r c), Past.LeftImp,
>                  ^^^^
> Warning 27: unused variable vars.
> File "bin/past_to_ast.ml", line 727, characters 29-30:
> 727 |       | Some Past.Boolean(_, b) -> (Ast.Bundle([Ast.Dec(Ast.Bool, nv); nv]), (Past.Bool, v1, e)::vars)
>                                    ^
> Warning 27: unused variable b.
> File "bin/past_to_ast.ml", line 852, characters 15-17:
> 852 |             | (dt, None) -> let Past.List(_, cells) = e1 in (Ast.MultiOp(Ast.And, List.map 
>                      ^^
> Warning 27: unused variable dt.
> File "bin/past_to_ast.ml", line 971, characters 12-17:
> 971 |         let expr2 = replace_utils e uninit_group in   
>                   ^^^^^
> Warning 26: unused variable expr2.
> File "bin/past_to_ast.ml", line 988, characters 60-61:
> 988 |     in ((r, c), flatten ((find_reg vars)::List.map (fun (e, v) -> e) translated), vars)
>                                                                   ^
> Warning 27: unused variable v.
